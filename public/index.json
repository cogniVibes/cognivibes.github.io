[{"content":"Were you aware that you can watch the entire \u0026ldquo;Star Wars: A New Hope\u0026rdquo; movie right in your terminal? It\u0026rsquo;s an incredible feat accomplished solely through the creative use of ASCII art.\nNow, let\u0026rsquo;s print a rotating cube, using nothing but asterisks (\u0026rsquo;*\u0026rsquo;). This project stresses on role of mathematics in the realm of computer science, particularly in the field of computer graphics.\nThe Cube There is however a problem, we are about to print a 3D object on a 2D plane. But let\u0026rsquo;s not worry about that for now. We will create a 3D cube and and then project it on the plane to make it look like it is 3D.\nHow do we create a 3D cube?\nWe are going to use the 3D co-ordinate system and start by assigning co-ordinates to the vertices of the cube.\nHow do we rotate the cube?\nWe will choose an angle $\\theta$ and use $\\sin\\theta$ and $cos\\theta$ to update the position of the vertices.\nLet\u0026rsquo;s start with the initial setup. We define some variables and parameters:\n1 2 3 4 5 6 7 8 9 import sys, time w, h, out = 80, 24, sys.stdout cube = [(x, y, z) for x in (-1, 1) for y in (-1, 1) for z in (-1, 1)] s = 0.1 # sine c = (1 - s**2)**0.5 # cosine ym = h/3 # Y magnification xm = 2*ym # X magnification Let\u0026rsquo;s understand what we did here:\nHere, w and h represent the width and height of the terminal. This determines the size of the cube. out is used to write to the terminal. cube is a list of coordinates representing the vertices of the cube. s and c represent the sine and cosine of a rotation angle. Notice we did not choose any angle $\\theta$ because we need to deal with the sine and cosine of the angle of rotation and the angle itself is not of much use. The range of the sine function is [-1, 1]. A negative value of sine will make the cube rotate in the opposite direction. We assigned the value of s 0.1. This is because our cube rotates by a very small angle per frame. The greater the value, the less smooth the rotation becomes, as the points (vertices) undergo more significant position updates. We don\u0026rsquo;t need $\\theta$ to calculate the cosine. Instead, we calculated the value of cosine using the basic trigonometric identity:\n$$\\sin^{2}\\theta + \\cos^{2}\\theta = 1$$\nym and xm are magnification factors for the Y and X axes, respectively. I will explain the role of ym and xm shortly when we project the cube into a 2D plane.\nRotation The core of this project is rotating the cube in 3D space. We use the following equations to perform the rotation1\n$$x\u0026rsquo; = c \\cdot x + s \\cdot z \\\\ y\u0026rsquo; = y \\\\ z\u0026rsquo; = -s \\cdot x + c \\cdot z$$\nHere, $x$, $y$, and $z$ are the original coordinates, and $x\u0026rsquo;$, $y\u0026rsquo;$, and $z\u0026rsquo;$ are the rotated coordinates. $c$ and $s$ are the cosine and sine values calculated earlier.\nNote: If a rectangular $xy$-coordinate system is rotated through an angle $\\theta$ to form an $x\u0026rsquo;y\u0026rsquo;$-coordinate system, then a point $P (x, y)$ will have coordinates $P (x\u0026rsquo;, y\u0026rsquo;)$ in the new system, where $(x, y)$ and $(x\u0026rsquo;,y\u0026rsquo;)$ are related by: $$x = x\u0026rsquo; \\cos\\theta ‚àí y\u0026rsquo; \\sin\\theta\\\\ y = x\u0026rsquo; \\sin\\theta + y\u0026rsquo; \\cos\\theta\\\\ \\text{and}\\\\ x\u0026rsquo; = x \\cos\\theta + y \\sin\\theta\\\\ y\u0026rsquo; = ‚àíx \\sin\\theta + y \\cos\\theta$$\rIn Python, the rotation is implemented as follows:\ncube = [(c*x + s*z, y, -s*x + c*z) for x, y, z in cube] # Rotate around the Y-axis The above code will make the cube rotate around the y-axis but you can also change the axis of rotation by changing the equations.\nFor example to change the axis of rotation to x-axis we can tweak the equations like this:\ncube = [(x, c*y + s*z, -s*y + c*z) for x, y, z in cube] # Rotate around the X-axis Projection Now that we have our rotated cube, we need to project it onto the 2D terminal screen. To do this, we use perspective projection. The projection equations are as follows:\n$$x_p = \\frac{x_m \\cdot x}{z + 2}$$\n$$y_p = \\frac{y_m \\cdot y}{z + 2}$$\nWhere $x_p$ and $y_p$ are the projected 2D coordinates on the terminal screen, and $x_m$ and $y_m$ are the X and Y magnification factors, respectively.\nHere, $x_m \\cdot x$ performs a scaling operation by multiplying the original x-coordinate \u0026lsquo;$x$\u0026rsquo; by the magnification factor for the x-axis \u0026lsquo;$x_m$\u0026rsquo;. This scaling operation alters the x-coordinate\u0026rsquo;s magnitude, essentially stretching or compressing the vertices\u0026rsquo; positions along the x-axis before the projection.\nThe (z+2) adjustment in the denominator is used for perspective projection. This modification is employed to create the effect of objects appearing smaller as they move away from the viewer, simulating depth in the rendered cube.\nIn Python, the projection is implemented as:\nproj = [(round(w/2+xm*x/(z+2)), round(h/2+ym*y/(z+2))) for x, y, z in cube] Rendering the Cube Finally, we draw the cube on the terminal screen. We iterate through the terminal\u0026rsquo;s rows and columns and check if the current pixel coordinates are in the proj list. If they are, we draw an asterisk (\u0026rsquo;*\u0026rsquo;); otherwise, we leave it empty (\u0026rsquo; \u0026lsquo;). The entire process is wrapped in an animation loop where the cube is rotated and redrawn continuously. A small delay time.sleep(1/15.0) is added to control the animation speed.\n1 2 3 4 5 out.write(\u0026#39;\\033[H\u0026#39; + \u0026#39;\\n\u0026#39;.join( \u0026#39;\u0026#39;.join((\u0026#39;*\u0026#39; if (x, y) in proj else \u0026#39; \u0026#39;) for x in range(w)) for y in range(h))) out.flush() time.sleep(1/15.0) This is what we will see if we run the program:\nFig 1. The cube in its current state\nAdding Edges We define a list of all edges.\n1 2 3 4 5 6 7 8 9 10 # Previous code ym = h/3 # Y magnification xm = 2*ym # X magnification # Define the edges of the cube as a list of vertex pairs. edges = [ (0, 1), (1, 3), (3, 2), (2, 0), # Bottom square (4, 5), (5, 7), (7, 6), (6, 4), # Top square (0, 4), (1, 5), (2, 6), (3, 7) # Connecting edges ] Each edge will have a start and an end point. The indices within each tuple pair correspond to the indices of the vertices within the cube list. For example, (0, 1) represents an edge connecting the vertices at indices 0 and 1 in the cube list, and so on.\nThen we draw the edges.\n1 2 3 4 5 6 7 8 9 10 11 12 # Previous code cube = [(c*x + s*z, y, -s*x + c*z) for x, y, z in cube] # Rotate around the Y-axis proj = [(round(w/2+xm*x/(z+2)), round(h/2+ym*y/(z+2))) for x, y, z in cube] # Draw the edges of the cube for edge in edges: start = proj[edge[0]] end = proj[edge[1]] for i in range(1, 9): # Interpolate between start and end for smoother lines x = start[0] + i * (end[0] - start[0]) // 10 y = start[1] + i * (end[1] - start[1]) // 10 proj.append((x, y)) This code segment operates within a loop iterating through each edge of the cube. edge iterates through each pair of vertices that make up an edge of the cube. start and end represent the projected 2D coordinates (x, y) of the vertices that form the current edge. A loop from i=1 to i=8 (inclusive) is used for interpolation to create smoother lines. This loop divides the line segment between start and end into 8 equal parts. For each value of i, it calculates new intermediate coordinates (x, y) between start and end. This is done by using linear interpolation formula: x = start[0] + i * (end[0] - start[0]) // 10 and y = start[1] + i * (end[1] - start[1]) // 10. This formula divides the line segment into 10 equal parts (// 10) and calculates intermediate points. The newly calculated coordinates (x, y) are appended to the proj list. This expands proj by adding more points that lie along the edges, resulting in a smoother representation of the cube when it\u0026rsquo;s projected onto the 2D screen.\nUpon running the code now we will see the cube along with its edges.\nFig 2. The final cube\nThe Complete Code Here is the final code. I recommend you experiment with it by changing the values in equations and variable initialization to better understand the function of each of them.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import sys, time w, h, out = 80, 24, sys.stdout cube = [(x, y, z) for x in (-1, 1) for y in (-1, 1) for z in (-1, 1)] s = 0.1 # sine c = (1 - s**2)**0.5 # cosine ym = h/3 # Y magnification xm = 2*ym # X magnification # Define the edges of the cube as a list of vertex pairs. edges = [ (0, 1), (1, 3), (3, 2), (2, 0), # Bottom square (4, 5), (5, 7), (7, 6), (6, 4), # Top square (0, 4), (1, 5), (2, 6), (3, 7) # Connecting edges ] while True: cube = [(c*x + s*z, y, -s*x + c*z) for x, y, z in cube] # Rotate around the Y-axis proj = [(round(w/2+xm*x/(z+2)), round(h/2+ym*y/(z+2))) for x, y, z in cube] # Draw the edges of the cube for edge in edges: start = proj[edge[0]] end = proj[edge[1]] for i in range(1, 9): # Interpolate between start and end for smoother lines x = start[0] + i * (end[0] - start[0]) // 10 y = start[1] + i * (end[1] - start[1]) // 10 proj.append((x, y)) out.write(\u0026#39;\\033[H\u0026#39; + \u0026#39;\\n\u0026#39;.join( \u0026#39;\u0026#39;.join((\u0026#39;*\u0026#39; if (x, y) in proj else \u0026#39; \u0026#39;) for x in range(w)) for y in range(h))) out.flush() time.sleep(1/15.0) Learn more about rotation of axes (pdf)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/dev/04/cube/","summary":"Learn to render a rotating 3D cube in the terminal.","title":"Rendering a Rotating 3D ASCII cube"},{"content":"Let\u0026rsquo;s create an outward opening spiral grid of numbers using Python. This pattern involves arranging numbers in a grid format that spirals outwards. We will do this by assigning coordinates to each number.\nFig 1. Outward Opening Spiral Grid\nThe Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def print_spiral_grid(n): # Initialize the grid with zeros grid = [[0] * n for _ in range(n)] num = n * n coords = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Directions: right, down, left, up direction_index = 0 row, col = 0, 0 for _ in range(n * n): grid[row][col] = num num -= 1 # Calculate the next position next_row = row + coords[direction_index][0] next_col = col + coords[direction_index][1] # Check if the next position is within bounds and not yet filled if 0 \u0026lt;= next_row \u0026lt; n and 0 \u0026lt;= next_col \u0026lt; n and grid[next_row][next_col] == 0: row, col = next_row, next_col else: direction_index = (direction_index + 1) % 4 row += coords[direction_index][0] col += coords[direction_index][1] # Print the grid for row in grid: print(\u0026#34; \u0026#34;.join(str(num).zfill(2) for num in row)) # Example usage n = int(input(\u0026#34;Enter the value of n: \u0026#34;)) print_spiral_grid(n) The code defines a Python function print_spiral_grid(n) that generates and prints a spiral grid of numbers from $n^2$ down to 1, following a clockwise pattern. Let\u0026rsquo;s break down the code step by step:\nInitialization grid = [[0] * n for _ in range(n)] This line initializes a 2D grid (list of lists) with dimensions $n$ by $n$ and fills it with zeros. This grid will hold the spiral pattern of numbers.\nnum = n * n This initializes a variable num with the value $n^2$. This will be used to populate the grid with decreasing numbers in a spiral manner.\ncoords = [(0, 1), (1, 0), (0, -1), (-1, 0)] This defines a list coords that contains four tuples representing directional changes. These tuples represent moving right, down, left, and up respectively.\ndirection_index = 0 row, col = 0, 0 direction_index keeps track of the current direction (initially set to 0 for moving right). row and col store the current position in the grid.\nAssigning Coordinates The loop iterates from 1 to $n^2$, filling the grid in a spiral pattern with decreasing numbers. Here\u0026rsquo;s what happens inside the loop:\ngrid[row][col] = num num -= 1 The current position in the grid is set to the current value of num, and num is decremented by 1 for the next iteration.\nnext_row = row + coords[direction_index][0] next_col = col + coords[direction_index][1] Calculate the next position based on the current direction.\nif 0 \u0026lt;= next_row \u0026lt; n and 0 \u0026lt;= next_col \u0026lt; n and grid[next_row][next_col] == 0: row, col = next_row, next_col else: direction_index = (direction_index + 1) % 4 row += coords[direction_index][0] col += coords[direction_index][1] Check if the next position is within bounds of the grid and hasn\u0026rsquo;t been filled already. If both conditions are met, move to the next position. Otherwise, change the direction (clockwise) and update the current position accordingly.\nPrinting the Grid After filling the grid with the spiral pattern, the code prints the grid using nested loops:\nfor row in grid: print(\u0026#34; \u0026#34;.join(str(num).zfill(2) for num in row)) It iterates through each row in the grid, formatting the numbers to have leading zeros if needed, and printing them with spaces in between.\nThe Program in Action Here is sample output that we get upon executing the program.\nEnter the value of n: 5 25 24 23 22 21 10 09 08 07 20 11 02 01 06 19 12 03 04 05 18 13 14 15 16 17 ","permalink":"http://localhost:1313/dev/03/spiral-grid/","summary":"Learn to print an outward opening spiral grid of numbers based on user input.","title":"Printing an Outward Opening Spiral Grid"},{"content":"NB: This post is also available on DEV Community.\nAbout Vigen√®re Cipher The Vigen√®re cipher is a classic encryption technique that dates back to the 16th century. It was invented by a French diplomat and cryptographer named Blaise de Vigen√®re, hence the name. It was known as ‚Äúle chiffre ind√©chiffrable,‚Äù which means ‚Äúthe indecipherable cipher,‚Äù and remained unbroken until British polymath Charles Babbage broke it in the 19th century.\nHow it works The Vigen√®re cipher is a polyalphabetic substitution cipher that uses a keyword to encrypt and decrypt messages. The key idea behind the Vigen√®re cipher is to use multiple Caesar ciphers based on the letters of the keyword.\nLet\u0026rsquo;s say we have a plaintext message $P$ consisting of $n$ letters: $P = p_1, p_2, \\ldots, p_n$‚Äã. We also have a keyword $K$ consisting of $m$ letters: $K = k_1, k_2, \\ldots, k_m$‚Äã, where $m \\leq n$.\nTo encrypt the message, we repeat the keyword until it matches the length of the plaintext. Let $K\u0026rsquo; = k_1, k_2, \\ldots, k_m, k_1, k_2, \\ldots, k_m, \\ldots$ repeated until it matches the length of $P$.\nTo encrypt each letter $p_i$‚Äã in the plaintext, we find the corresponding letter $k_j$‚Äã in the keyword $K\u0026rsquo;$ where $j$ is the index of $p_i$‚Äã modulo $m$. Then, we shift the letter $p_i$‚Äã by the index of $k_j$‚Äã in the alphabet. Let $E$ represent the encrypted message.\nThe mathematical representation of the encryption process is given by: $$E_i = (p_i + k_j) \\mod 26$$ where $E_i$‚Äã is the $i$-th letter of the encrypted message and $j = (i‚àí1) \\mod m$.\nTo decrypt the message, we use a similar process. We repeat the keyword until it matches the length of the ciphertext. Let $K\u0026rsquo;\u0026rsquo; = k_1, k_2, \\ldots, k_m, k_1, k_2, \\ldots, k_m, \\ldots$ (repeated until it matches the length of $E$).\nTo decrypt each letter $E_i$‚Äã in the ciphertext, we find the corresponding letter $k_j$‚Äã in the keyword $K\u0026rsquo;$ (where $j$ is the index of $E_i$‚Äã modulo $m$). Then, we shift the letter $E_i‚Äã$ back by the index of $k_j$‚Äã in the alphabet. Let $D$ represent the decrypted message.\nThe mathematical representation of the decryption process is given by: $$D_i = (Ei‚àíkj) \\mod‚Äâ26$$ where $D_i$‚Äã is the $i$-th letter of the decrypted message and $j = (i‚àí1) \\mod‚Äâm$.\nNote: In these equations, we use modular arithmetic with $26$ since there are $26$ letters in the English alphabet. Additionally, we assume a simple mapping where $A$ is represented by $0$, $B$ by $1$, and so on.\rExample Let\u0026rsquo;s use the word \u0026ldquo;KEY\u0026rdquo; as the keyword and encrypt the plaintext message \u0026ldquo;HELLO\u0026rdquo; using the Vigen√®re cipher.\nFirst, we repeat the keyword \u0026ldquo;KEY\u0026rdquo; to match the length of the plaintext \u0026ldquo;HELLO\u0026rdquo;. Thus, the repeated keyword becomes \u0026ldquo;KEYKE\u0026rdquo;.\nThe corresponding numerical representation of the plaintext message \u0026ldquo;HELLO\u0026rdquo; is: $$H \\rightarrow 7\\\\ E \\rightarrow 4\\\\ L \\rightarrow 11\\\\ L \\rightarrow 11\\\\ O \\rightarrow 14$$\nUsing the mathematical encryption formula $E_i = (p_i+k_j) \\mod‚Äâ26$, we can calculate the encrypted values as follows: $$E_1 = (7 + 10) \\mod 26 = 17 \\rightarrow R\\\\ E_2 = (4 + 4) \\mod 26 = 8 \\rightarrow I\\\\ E_3 = (11 + 24) \\mod 26 = 9 \\rightarrow J\\\\ E_4 = (11 + 10) \\mod 26 = 21 \\rightarrow V\\\\ E_5 = (14 + 4) \\mod 26 = 18 \\rightarrow S$$\nThus, the encrypted message is \u0026ldquo;RIJVS\u0026rdquo;.\nTo decrypt the ciphertext \u0026ldquo;RIJVS\u0026rdquo; back to the original plaintext, we repeat the keyword \u0026ldquo;KEY\u0026rdquo; to match the length of the ciphertext. Thus, the repeated keyword becomes \u0026ldquo;KEYKE\u0026rdquo;.\nUsing the mathematical decryption formula $D_i=(E_i‚àík_j) \\mod‚Äâ26$, we can calculate the decrypted values as follows: $$D_1 = (17 - 10) \\mod 26 = 7 \\rightarrow H\\\\ D_2 = (8 - 4) \\mod 26 = 4 \\rightarrow E\\\\ D_3 = (9 - 24) \\mod 26 = 11 \\rightarrow L\\\\ D_4 = (21 - 10) \\mod 26 = 11 \\rightarrow L\\\\ D_5 = (18 - 4) \\mod 26 = 14 \\rightarrow O$$\nThus, the decrypted message is \u0026ldquo;HELLO\u0026rdquo;.\nVigen√®re Table Encryption/decryption in case of Vigen√®re Cipher is a tedious task. The Vigen√®re table, also known as the Vigen√®re square or the Tabula Recta, is used to simplify the process of encryption and decryption.\nFig 1. The Vigen√®re Table\nIt consists of a grid or matrix that provides a systematic way of encrypting and decrypting messages using the Vigen√®re cipher. The table is formed by aligning multiple Caesar ciphers together, each with a different shift value determined by a keyword. The rows and columns of the table represent the letters of the alphabet, and each cell contains the letter resulting from combining the row and column letters using the Caesar cipher.\nThe Code The encryption-decryption script can be downloaded from here.\nHere is the source code of encryption_decryption.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def vigenere_cipher(text, keyword, mode): result = \u0026#34;\u0026#34; keyword_length = len(keyword) keyword = keyword.upper() key_index = 0 for i, char in enumerate(text): if char.isalpha(): ascii_offset = ord(\u0026#39;A\u0026#39;) if char.isupper() else ord(\u0026#39;a\u0026#39;) keyword_shift = ord(keyword[key_index % keyword_length]) - ord(\u0026#39;A\u0026#39;) if mode == \u0026#34;decrypt\u0026#34;: keyword_shift = -keyword_shift # Reverse the shift for decryption char = chr((ord(char) - ascii_offset + keyword_shift) % 26 + ascii_offset) key_index+=1 result += char return result # Get mode while True: print(\u0026#39;Do you want to (e)ncrypt or (d)ecrypt?\u0026#39;) response = input(\u0026#39;\u0026gt; \u0026#39;).lower() if response.startswith(\u0026#39;e\u0026#39;): action = \u0026#39;encrypt\u0026#39; break elif response.startswith(\u0026#39;d\u0026#39;): action = \u0026#39;decrypt\u0026#39; break print(\u0026#39;Please enter the letter e or d.\u0026#39;) print(\u0026#34;Enter the message.\u0026#34;) message = input(\u0026#39;\u0026gt; \u0026#39;) print(\u0026#34;Enter the keyword.\u0026#34;) keyword = input(\u0026#39;\u0026gt; \u0026#39;).upper() # Perform encryption/decryption result = vigenere_cipher(message, keyword, action) # Display the result print(f\u0026#34;Result: {result}\u0026#34;) The vigenere_cipher function performs the encryption or decryption operation based on the provided parameters. It initializes an empty string called result to store the final result. It calculates the length of the keyword and converts it to uppercase.\nNext, it iterates through each character in the text input. If the character is a letter, it determines whether it is uppercase or lowercase and assigns an ASCII offset accordingly. It calculates the shift value for the current character based on the corresponding letter in the keyword. If the mode is set to \u0026ldquo;decrypt,\u0026rdquo; it reverses the shift value.\nThen, it applies the shift to the current character by subtracting the ASCII offset, adding the keyword shift, and taking the modulo 26 to wrap around the alphabet. Finally, it converts the shifted value back to a character using the ASCII offset and appends it to the result string. The key_index is incremented to ensure the keyword characters are used cyclically.\nAfter processing all characters in the text, the result string contains the encrypted or decrypted message, depending on the mode.\nThe code prompts the user to enter the encryption or decryption mode (encrypt or decrypt) and stores the response in the action variable. It keeps asking for input until a valid mode is provided.\nThen, it asks the user to enter the message and keyword, storing them in the message and keyword variables, respectively.\nThe vigenere_cipher function is called with the provided inputs (message, keyword, and action), and the result is stored in the result variable.\nThe Program in Action Here is a sample output that we get upon executing the program:\nDo you want to (e)ncrypt or (d)ecrypt? \u0026gt; e Enter the message. \u0026gt; Enemy is approaching! Send troops immediately! Enter the keyword. \u0026gt; Moonlight Result: Qbszj qy hibfcnnpouz! Esbq ezuvie wazplohmqzm! Do you want to (e)ncrypt or (d)ecrypt? \u0026gt; d Enter the message. \u0026gt; Qbszj qy hibfcnnpouz! Esbq ezuvie wazplohmqzm! Enter the keyword. \u0026gt; Moonlight Result: Enemy is approaching! Send troops immediately! Here the key used is Moonlight.\nConclusion There are several ways to hack the Vigen√®re Cipher, such as Kasiski examination, Friedman test, frequency analysis, dictionary attack, etc. However, these are advanced methods and require complex application of combinatorics and statistics. Discussing even one of those would require a separate post. For now we will focus on encryption and decryption. I will surely post a Vigen√®re hack tutorial in future.\nNote: Vigen√®re Cipher, although complex, is still too easy to break using modern methods and should not be used for serious encryption purposes.\r","permalink":"http://localhost:1313/dev/02/vigenere-cipher/","summary":"Learn to encrypt or decrypt a Vigen√®re Cipher","title":"Understanding the Vigen√®re Cipher"},{"content":"NB: This post is also available on DEV Community.\nIntroduction Cryptography is the practice of secure communication in the presence of third parties. Throughout history, people have used various techniques to protect their messages, ranging from simple substitution ciphers to more advanced encryption methods. Caesar Cipher is a classical encryption method that will be discussed in this post. It is not used much nowadays as it is very easy to crack. However, it fulfils the purpose of teaching and casual encryption where security is not the main concern.\nAbout Caesar Cipher Caesar Cipher is one of the oldest and simplest encryption algorithms. It is named after Julius Caesar, who used it to communicate secretly with his generals. The idea behind Caesar Cipher is to replace each letter in the plaintext with a letter that is a fixed number of positions down the alphabet. For example, if the key is 3, then each letter in the plaintext will be replaced by the letter that is three positions down the alphabet. Thus, \u0026lsquo;A\u0026rsquo; becomes \u0026lsquo;D\u0026rsquo;, \u0026lsquo;B\u0026rsquo; becomes \u0026lsquo;E\u0026rsquo;, \u0026lsquo;C\u0026rsquo; becomes \u0026lsquo;F\u0026rsquo;, and so on.\nHow it works Caesar Cipher works by shifting each letter in the plaintext by a fixed number of positions down the alphabet. The number of positions shifted is known as the key or the shift value. The formula for encrypting a letter using Caesar Cipher is:\nE(x) = (x + k) mod 26 where x is the numerical value of the letter (A=0, B=1, C=2, \u0026hellip;, Z=25), k is the key or the shift value, and mod 26 means to take the remainder when divided by 26.\nTo decrypt a letter, the formula is:\nD(x) = (x - k) mod 26 where x is the numerical value of the encrypted letter, k is the key or the shift value, and mod 26 means to take the remainder when divided by 26.\nExample Suppose the plaintext is \u0026ldquo;HELLO\u0026rdquo; and the key is 3. Then each letter in the plaintext is shifted by 3 positions down the alphabet, according to the encryption formula:\nH -\u0026gt; K\rE -\u0026gt; H\rL -\u0026gt; O L -\u0026gt; O\rO -\u0026gt; R So the ciphertext is \u0026ldquo;KHOOR\u0026rdquo;. To decrypt the ciphertext, we simply shift each letter back by 3 positions, according to the decryption formula:\nK -\u0026gt; H\rH -\u0026gt; E\rO -\u0026gt; L\rO -\u0026gt; L\rR -\u0026gt; O So the plaintext is \u0026ldquo;HELLO\u0026rdquo; again.\nEncryption table and the Caesar wheel To make it easier to perform encryption and decryption, we can create a table that shows the correspondence between the plaintext letters and the ciphertext letters, as well as the numerical values of the letters. Suppose the key is 23 then the encryption table will look like this.\nFig 1. Encryption Table\nAnother tool to make it easier to perform encryption or decryption in Caesar cipher is the Caesar wheel. The Caesar cipher wheel is a tool used for encryption and decryption in cryptography. It consists of a circular disk with the letters of the alphabet written around its circumference in a specific order. The disk can be rotated to any position, allowing the user to shift the letters a certain number of places to the right or left. To encrypt a message, each letter of the plaintext is replaced with the letter that is a certain number of positions to the right on the wheel. To decrypt the message, the process is reversed by shifting the letters to the left.\nFig 2. The Caesar Wheel\nThe Code I chose the python programming language because it is straightforward and simple to understand. The encryption-decryption script as well as the hacking script can be downloaded from here if you do not want to write the code yourself or copy-paste the code. However, if you are a beginner to coding, I suggest you type the code yourself as that will give you a better understanding.\nEncryption and Decryption Here is the source code for encryption_decription.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # This code will encrypt or decrypt a Caesar Cipher # Core encryption/decryption function def caesar_cipher(text, shift, mode): result = \u0026#34;\u0026#34; if mode == \u0026#34;decrypt\u0026#34;: shift = -shift # Reverse the shift for decryption for char in text: if char.isalpha(): ascii_offset = ord(\u0026#39;A\u0026#39;) if char.isupper() else ord(\u0026#39;a\u0026#39;) char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset) result += char return result # Get mode while True: print(\u0026#39;Do you want to (e)ncrypt or (d)ecrypt?\u0026#39;) response = input(\u0026#39;\u0026gt; \u0026#39;).lower() if response.startswith(\u0026#39;e\u0026#39;): action = \u0026#39;encrypt\u0026#39; break elif response.startswith(\u0026#39;d\u0026#39;): action = \u0026#39;decrypt\u0026#39; break print(\u0026#39;Please enter the letter e or d.\u0026#39;) print(\u0026#34;Enter the message.\u0026#34;) message = input(\u0026#39;\u0026gt; \u0026#39;) # Get shift value while True: maxKey = 26 print(\u0026#39;Please enter the key (0 to 25) to use.\u0026#39;) response = input(\u0026#39;\u0026gt; \u0026#39;).upper() if not response.isdecimal(): continue if 0 \u0026lt;= int(response) \u0026lt; 26: key = int(response) break # Perform encryption/decryption result = caesar_cipher(message, key, action) # Display the result print(f\u0026#34;Result: {result}\u0026#34;) Let\u0026rsquo;s understand how the script works.\nThe caesar_cipher() function takes in three parameters: text is the message to encrypt or decrypt, shift is the number of positions to shift each letter, and mode specifies whether to encrypt or decrypt.\nThe if char.isalpha(): condition checks if the character is a letter. It ensures that only alphabetic characters are processed, ignoring any other characters such as spaces or punctuation.\nIf the character is a letter, the code determines the ASCII offset based on whether the letter is uppercase or lowercase. If the character is uppercase, the ASCII offset is set to the value of \u0026lsquo;A\u0026rsquo; (65 in ASCII), and if the character is lowercase, the offset is set to the value of \u0026lsquo;a\u0026rsquo; (97 in ASCII).\nNext, the code performs the shift operation on the character. It subtracts the ASCII offset from the current character\u0026rsquo;s ASCII value, then adds the shift value, and finally applies the modulo operator % 26 to ensure that the result stays within the range of the alphabet. This step effectively shifts the character by the specified number of positions.\nAfter the character has been shifted, it is converted back to a character using the chr() function, and the resulting character is concatenated to the result variable.\nThis process is repeated for each character in the input text, resulting in the encryption or decryption of the entire message.\nThe program prompts the user to select whether to encrypt or decrypt, and then prompts for the message to encrypt/decrypt and the shift value. The caesar_cipher() function is called with the appropriate parameters, and the result is displayed.\nThe Program in Action Here is an example of what the output would be upon executing encryption_decryption.py:\nDo you want to (e)ncrypt or (d)ecrypt? \u0026gt; e Enter the message. \u0026gt; Enemy is approaching! Send troops immediately! Please enter the key (0 to 25) to use. \u0026gt; 11 Result: Pypxj td laaczlnstyr! Dpyo eczzad txxpotlepwj! Do you want to (e)ncrypt or (d)ecrypt? \u0026gt; d Enter the message. \u0026gt; Pypxj td laaczlnstyr! Dpyo eczzad txxpotlepwj! Please enter the key (0 to 25) to use. \u0026gt; 11 Result: Enemy is approaching! Send troops immediately! That\u0026rsquo;s it for encryption_decryption.py. Let\u0026rsquo;s move on to hacking the Caesar Cipher.\nHacking the Caesar Cipher To hack the Caesar cipher we use a technique called the brute force technique also known as exhaustive search.\nIn cryptography, brute force attack is a method of trying all possible keys or passwords to decrypt encrypted data. It involves systematically attempting every combination until the correct one is found. This technique can be time-consuming and computationally expensive, especially with longer and more complex keys. To protect against brute force attacks, cryptographic systems use stronger and longer keys, making it practically infeasible to try all combinations within a reasonable timeframe.\nHowever, brute force can be effective against the Caesar cipher because the Caesar cipher has a small key space and a limited number of possible keys. The Caesar cipher is a simple substitution cipher that shifts each letter of the plaintext by a fixed number of positions in the alphabet. Since there are only 26 possible shifts in the English alphabet, a brute force attack can easily try all 26 possibilities to decrypt the ciphertext. By systematically trying each shift, the correct plaintext can be discovered.\nUnfortunately, brute force technique isn‚Äôt sophisticated enough to identify when it has found the correct key. It relies on a human to read the output and identify which decryption produced the original English message.\nHere is the hack script named decipher.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # This code will decipher a Caesar Cipher # Get cipher text print(\u0026#34;Enter the Caesar Cipher text\u0026#34;) message = input(\u0026#34;\u0026gt; \u0026#34;) for shift in range(26): result = \u0026#39;\u0026#39; for char in message: if char.isalpha(): ascii_offset = ord(\u0026#39;A\u0026#39;) if char.isupper() else ord(\u0026#39;a\u0026#39;) char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset) result += char print(f\u0026#34;Key: {shift} | Decrypted message: {result}\u0026#34;) Note that code is nearly identical to the caesar_cipher() function of encryption_decryption.py. The hacking program implements the same decryption logic, except that it does so in a for loop, which runs the code for every possible key.\nHere is a sample output of the above code:\nEnter the Caesar Cipher text \u0026gt; Pypxj td laaczlnstyr! Dpyo eczzad txxpotlepwj! Key: 0 | Decrypted message: Pypxj td laaczlnstyr! Dpyo eczzad txxpotlepwj! Key: 1 | Decrypted message: Oxowi sc kzzbykmrsxq! Coxn dbyyzc swwonskdovi! Key: 2 | Decrypted message: Nwnvh rb jyyaxjlqrwp! Bnwm caxxyb rvvnmrjcnuh! Key: 3 | Decrypted message: Mvmug qa ixxzwikpqvo! Amvl bzwwxa quumlqibmtg! Key: 4 | Decrypted message: Lultf pz hwwyvhjopun! Zluk ayvvwz pttlkphalsf! Key: 5 | Decrypted message: Ktkse oy gvvxuginotm! Yktj zxuuvy osskjogzkre! Key: 6 | Decrypted message: Jsjrd nx fuuwtfhmnsl! Xjsi ywttux nrrjinfyjqd! Key: 7 | Decrypted message: Iriqc mw ettvseglmrk! Wirh xvsstw mqqihmexipc! Key: 8 | Decrypted message: Hqhpb lv dssurdfklqj! Vhqg wurrsv lpphgldwhob! Key: 9 | Decrypted message: Gpgoa ku crrtqcejkpi! Ugpf vtqqru koogfkcvgna! Key: 10 | Decrypted message: Fofnz jt bqqspbdijoh! Tfoe usppqt jnnfejbufmz! Key: 11 | Decrypted message: Enemy is approaching! Send troops immediately! Key: 12 | Decrypted message: Dmdlx hr zooqnzbghmf! Rdmc sqnnor hlldchzsdkx! Key: 13 | Decrypted message: Clckw gq ynnpmyafgle! Qclb rpmmnq gkkcbgyrcjw! Key: 14 | Decrypted message: Bkbjv fp xmmolxzefkd! Pbka qollmp fjjbafxqbiv! Key: 15 | Decrypted message: Ajaiu eo wllnkwydejc! Oajz pnkklo eiiazewpahu! Key: 16 | Decrypted message: Zizht dn vkkmjvxcdib! Nziy omjjkn dhhzydvozgt! Key: 17 | Decrypted message: Yhygs cm ujjliuwbcha! Myhx nliijm cggyxcunyfs! Key: 18 | Decrypted message: Xgxfr bl tiikhtvabgz! Lxgw mkhhil bffxwbtmxer! Key: 19 | Decrypted message: Wfweq ak shhjgsuzafy! Kwfv ljgghk aeewvaslwdq! Key: 20 | Decrypted message: Vevdp zj rggifrtyzex! Jveu kiffgj zddvuzrkvcp! Key: 21 | Decrypted message: Uduco yi qffheqsxydw! Iudt jheefi yccutyqjubo! Key: 22 | Decrypted message: Tctbn xh peegdprwxcv! Htcs igddeh xbbtsxpitan! Key: 23 | Decrypted message: Sbsam wg oddfcoqvwbu! Gsbr hfccdg waasrwohszm! Key: 24 | Decrypted message: Rarzl vf nccebnpuvat! Fraq gebbcf vzzrqvngryl! Key: 25 | Decrypted message: Qzqyk ue mbbdamotuzs! Eqzp fdaabe uyyqpumfqxk! Conclusion Previously, I mentioned that Caesar Cipher is not suitable for serious encryption purposes. This post is intended for beginners who are interested in exploring the field of cryptography and want to enhance their programming skills. While there are numerous encryption methods available, Caesar Cipher is one of the most straightforward to understand. However, I will be posting more content in the future that discusses other types of ciphers in greater depth.\n","permalink":"http://localhost:1313/dev/01/caesar-cipher/","summary":"Learn to encrypt or decrypt a Caesar Cipher or hack it","title":"Hacking the Caesar Cipher"},{"content":"Hi there! üëã\nMy name is Ayush Saha and I am a high school student üë®‚Äçüéì from West Bengal, India.\nWelcome to my blog and thank you for taking the time to visit.\nI created this blog as an opportunity to share my hobby with a broader audience and to practice and improve my programming skills in the process.\nAs you read through my articles, my hope is that you\u0026rsquo;ll gain new insights and perspectives on the topics I write about. I like to explore ideas and share them with people.\nSo grab a cup of coffee ‚òï, make yourself comfortable, and let\u0026rsquo;s explore together!\nContact Me Email - ayushsahaaltacc@gmail.com (public)\nThat\u0026rsquo;s it, I only have Email. I don\u0026rsquo;t do social media (for now).\n","permalink":"http://localhost:1313/about/","summary":"Hi there! üëã\nMy name is Ayush Saha and I am a high school student üë®‚Äçüéì from West Bengal, India.\nWelcome to my blog and thank you for taking the time to visit.\nI created this blog as an opportunity to share my hobby with a broader audience and to practice and improve my programming skills in the process.\nAs you read through my articles, my hope is that you\u0026rsquo;ll gain new insights and perspectives on the topics I write about.","title":"About"}]